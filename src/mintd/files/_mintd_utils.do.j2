* mintd utility functions for {{ project_name }}
*
* This do-file provides common utilities used across all project scripts.
* DO NOT MODIFY - This file is managed by mintd and will be overwritten.
*
* NOTE: Scripts are expected to run from the code/ directory.
* Data paths should use "../data/" to access the data folder.

* =============================================================================
* GLOBAL PATH DEFINITIONS
* =============================================================================
* These paths are relative to code/ where scripts run from

global DATA_DIR "../data"
global RAW_DIR "../data/raw"
global ANALYSIS_DIR "../data/analysis"
global INTERMEDIATE_DIR "../data/intermediate"
global FINAL_DIR "../data/final"

* =============================================================================
* SETUP PROJECT DIRECTORY
* =============================================================================

capture program drop setup_project_directory
program define setup_project_directory
    * Validate we're running from the code/ directory within a mint project

    local current_dir "`c(pwd)'"

    * Check if we're in code/ by looking for project indicators in parent
    local root_indicators "metadata.json .git"
    local is_in_src = 0

    * Check if parent directory has project indicators (we're in code/)
    foreach indicator of local root_indicators {
        capture confirm file "../`indicator'"
        if !_rc {
            local is_in_src = 1
            continue, break
        }
    }

    if `is_in_src' {
        display "Running from code/ directory: `current_dir'"
        display "Project root: `current_dir'/.."
        exit
    }

    * Check if we're in the project root (for backwards compatibility)
    local root_found = 0
    foreach indicator of local root_indicators {
        capture confirm file "`indicator'"
        if !_rc {
            local root_found = 1
            continue, break
        }
    }

    if `root_found' {
        display as text "Note: Running from project root. Consider running from code/"
        display "Project root: `current_dir'"

        * Update globals for project-root execution (backwards compatibility)
        global DATA_DIR "data"
        global RAW_DIR "data/raw"
        global ANALYSIS_DIR "data/analysis"
        global INTERMEDIATE_DIR "data/intermediate"
        global FINAL_DIR "data/final"
        exit
    }

    * Not in a valid location
    display as error "Not running from expected directory."
    display as error "Scripts should be run from code/ directory."
    display as error "Current directory: `current_dir'"
    display as error "Please cd to the project's code/ directory and try again."
    error 1
end

* =============================================================================
* PARAMETER-AWARE LOGGER
* =============================================================================

capture program drop ParameterAwareLogger
program define ParameterAwareLogger
    * Initialize parameter-aware logging
    args script_name

    * Validate directory and set up globals
    setup_project_directory

    * Create logs directory
    local logs_dir "../logs"
    capture mkdir "`logs_dir'"

    * Parse command line arguments for parameters
    local params ""
    local args_to_parse "`0'"

    * Look for common parameter patterns
    if strpos("`args_to_parse'", "--year=") > 0 {
        local year_pos = strpos("`args_to_parse'", "--year=")
        local year_rest = substr("`args_to_parse'", `year_pos' + 7, .)
        local year_val = substr("`year_rest'", 1, strpos("`year_rest'", " ") - 1)
        if "`year_val'" == "" {
            local year_val = "`year_rest'"
        }
        local params "`params'`year_val'_"
    }

    if strpos("`args_to_parse'", "--version=") > 0 {
        local ver_pos = strpos("`args_to_parse'", "--version=")
        local ver_rest = substr("`args_to_parse'", `ver_pos' + 10, .)
        local ver_val = substr("`ver_rest'", 1, strpos("`ver_rest'", " ") - 1)
        if "`ver_val'" == "" {
            local ver_val = "`ver_rest'"
        }
        local params "`params'`ver_val'_"
    }

    * Check for positional arguments (first non-option argument)
    local first_arg ""
    foreach part of local args_to_parse {
        if !strpos("`part'", "--") & "`part'" != "`script_name'" {
            local first_arg "`part'"
            continue, break
        }
    }

    * If first arg looks like a parameter (short, alphanumeric), use it
    if "`first_arg'" != "" & length("`first_arg'") <= 10 & regexm("`first_arg'", "^[a-zA-Z0-9_]+$") {
        local params "`params'`first_arg'_"
    }

    * Clean up trailing underscore
    local params = subinstr("`params'", "_$", "", .)

    * Create log filename
    local timestamp = string(date("`c(current_date)'", "dmy"), "%tdCCYYNNDD") + "_" + ///
                     string(clock("`c(current_time)'", "hms"), "%tcHHMMSS")

    if "`params'" != "" {
        local log_filename "`script_name'_`params'.log"
    }
    else {
        local log_filename "`script_name'_`timestamp'.log"
    }

    local log_path "`logs_dir'/`log_filename'"

    * Initialize log file
    capture log close _mint_log
    quietly log using "`log_path'", replace name(_mint_log) text

    * Write header
    display "================================================================================"
    display "Script: `script_name'"
    display "Command: `0'"
    display "Working directory: `c(pwd)'"
    display "Stata version: `c(version)'"
    display "Start time: `c(current_date)' `c(current_time)'"
    display "================================================================================"
end

capture program drop log_message
program define log_message
    * Log a message with timestamp
    args message level

    if "`level'" == "" {
        local level "INFO"
    }

    display "[`c(current_time)'] `level': `message'"
end

capture program drop close_logger
program define close_logger
    * Close the logger and write final information

    display "================================================================================"
    display "End time: `c(current_date)' `c(current_time)'"
    display "================================================================================"

    capture log close _mint_log
end

* =============================================================================
* DATA SCHEMA GENERATION
* =============================================================================

capture program drop generate_data_schema
program define generate_data_schema
    * Generate JSON schema from data file
    args data_path output_path

    * Check if file exists
    capture confirm file "`data_path'"
    if _rc {
        display as error "Data file not found: `data_path'"
        error 1
    }

    * Load data based on extension
    local ext = lower(substr("`data_path'", strrpos("`data_path'", ".") + 1, .))

    if "`ext'" == "csv" {
        quietly import delimited "`data_path'", clear
    }
    else if "`ext'" == "dta" {
        quietly use "`data_path'", clear
    }
    else {
        display as error "Unsupported file format: `ext'"
        display as error "Supported formats: csv, dta"
        error 1
    }

    * Generate schema information
    local filename = substr("`data_path'", strrpos("`data_path'", "/") + 1, .)
    local observations = _N
    local columns = c(k)

    * Start building JSON schema
    tempname schema_file
    tempfile schema_temp
    file open `schema_file' using "`schema_temp'", write text

    file write `schema_file' "{" _n
    file write `schema_file' `"  "filename": "`filename'","' _n
    file write `schema_file' `"  "filepath": "`data_path'","' _n
    file write `schema_file' `"  "observations": `observations',"'
    file write `schema_file' `"  "columns": `columns',"'
    file write `schema_file' `"  "variables": ["' _n

    * Process each variable
    forvalues i = 1/`columns' {
        local varname : word `i' of `c(varlist)'
        local vartype : type `varname'

        * Determine variable type
        if strpos("`vartype'", "str") == 1 {
            local var_type "string"
        }
        else if strpos("`vartype'", "byte") == 1 | strpos("`vartype'", "int") == 1 | strpos("`vartype'", "long") == 1 {
            local var_type "integer"
        }
        else if strpos("`vartype'", "float") == 1 | strpos("`vartype'", "double") == 1 {
            local var_type "numeric"
        }
        else {
            local var_type "`vartype'"
        }

        * Generate label from variable name
        local label = subinstr("`varname'", "_", " ", .)
        local label = proper("`label'")

        * Count missing values
        quietly count if missing(`varname')
        local missing_count = r(N)

        * Count unique values for strings
        local unique_values "null"
        if "`var_type'" == "string" {
            quietly levelsof `varname', local(levels)
            local unique_values : word count `levels'
        }

        * Write variable info
        file write `schema_file' "    {" _n
        file write `schema_file' `"      "name": "`varname'","' _n
        file write `schema_file' `"      "type": "`var_type'","' _n
        file write `schema_file' `"      "label": "`label'","' _n
        file write `schema_file' `"      "missing_count": `missing_count''

        if "`var_type'" == "string" & "`unique_values'" != "null" {
            file write `schema_file' `","' _n `"      "unique_values": `unique_values'' _n
        }
        else if "`var_type'" == "integer" | "`var_type'" == "numeric" {
            * Add numeric statistics
            quietly summarize `varname'
            file write `schema_file' "," _n
            file write `schema_file' `"      "min": `r(min)'' _n
            file write `schema_file' `"      "max": `r(max)'' _n
            file write `schema_file' `"      "mean": `r(mean)'' _n
            file write `schema_file' `"      "sd": `r(sd)'' _n
        }
        else {
            file write `schema_file' _n
        }

        * Close variable object
        if `i' < `columns' {
            file write `schema_file' "    }," _n
        }
        else {
            file write `schema_file' "    }" _n
        }
    }

    file write `schema_file' "  ]" _n
    file write `schema_file' "}" _n
    file close `schema_file'

    * Save schema if output path provided
    if "`output_path'" != "" {
        * Ensure output directory exists
        local out_dir = substr("`output_path'", 1, strrpos("`output_path'", "/") - 1)
        capture mkdir "`out_dir'"

        copy "`schema_temp'" "`output_path'", replace
        display "Schema saved to: `output_path'"
    }
    else {
        * Display schema content
        type "`schema_temp'"
    }
end

* =============================================================================
* FIND DATA FILES
* =============================================================================

capture program drop find_data_files
program define find_data_files
    * Find data files in a directory
    args directory

    local extensions "csv dta json xlsx xls rds sav"
    local found_files ""

    foreach ext of local extensions {
        local pattern "`directory'/*.`ext'"
        local files : dir "`directory'" files "*.`ext'", respectcase

        foreach file of local files {
            local found_files "`found_files' `directory'/`file'"
        }
    }

    * Return sorted list
    display "`found_files'"
end
